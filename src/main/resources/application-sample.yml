server:
  port: 8086
  servlet:
    context-path: /order

eureka:
  client:
    service-url:
      defaultZone: ${EUREKA_HOST}/eureka/
    register-with-eureka: true
    fetch-registry: true

spring:
  config:
    import: optional:file:./.env[.properties]

  main:
    allow-bean-definition-overriding: true

  application:
    name: order-to-shipping-service

  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 3

  data:
    redis:
      host: ${REDIS_HOST}
      port: 6379
      password:
      timeout: 2000

  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        show_sql: true
        default_batch_fetch_size: 100
    open-in-view: false

  sql:
    init:
      mode: never  # schema.sql, data.sql 자동 실행 끄기 (필요하면 always 로 변경)

  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP}
    topics:
      hub: ${HUB_TOPIC}
      shipping-message: ${SHIPPING_MESSAGE_TOPIC}
      order: ${ORDER_TOPIC}
    consumer:
      group-id: ${CONSUMER_GROUP_ID}

logging:
  level:
    org.hibernate.SQL: debug
    org.hibernate.type.descriptor.sql.BasicBinder: trace

toss:
  base-url: ${TOSS_BASE_URL}
  secret-key: ${TOSS_SECRET_KEY}

feign:
  client:
    config:
      tossPaymentsClient:
        loggerLevel: FULL
        connectTimeout: 5000
        readTimeout: 10000

gemini:
  url: ${GEMINI_URL}
  api-key: ${GEMINI_API_KEY}

resilience4j:
  circuitbreaker:
    configs:
      default:  # 기본 구성 이름
        registerHealthIndicator: true  # 애플리케이션의 헬스 체크에 서킷 브레이커 상태를 추가하여 모니터링 가능
        # 서킷 브레이커가 동작할 때 사용할 슬라이딩 윈도우의 타입을 설정
        # COUNT_BASED: 마지막 N번의 호출 결과를 기반으로 상태를 결정
        # TIME_BASED: 마지막 N초 동안의 호출 결과를 기반으로 상태를 결정
        slidingWindowType: COUNT_BASED  # 슬라이딩 윈도우의 타입을 호출 수 기반(COUNT_BASED)으로 설정
        # 슬라이딩 윈도우의 크기를 설정
        # COUNT_BASED일 경우: 최근 N번의 호출을 저장
        # TIME_BASED일 경우: 최근 N초 동안의 호출을 저장
        slidingWindowSize: 5  # 슬라이딩 윈도우의 크기를 5번의 호출로 설정
        minimumNumberOfCalls: 5  # 서킷 브레이커가 동작하기 위해 필요한 최소한의 호출 수를 5로 설정
        slowCallRateThreshold: 100  # 느린 호출의 비율이 이 임계값(100%)을 초과하면 서킷 브레이커가 동작
        slowCallDurationThreshold: 60000  # 느린 호출의 기준 시간(밀리초)으로, 60초 이상 걸리면 느린 호출로 간주
        failureRateThreshold: 50  # 실패율이 이 임계값(50%)을 초과하면 서킷 브레이커가 동작
        permittedNumberOfCallsInHalfOpenState: 3  # 서킷 브레이커가 Half-open 상태에서 허용하는 최대 호출 수를 3으로 설정
        # 서킷 브레이커가 Open 상태에서 Half-open 상태로 전환되기 전에 기다리는 시간
        waitDurationInOpenState: 20s  # Open 상태에서 Half-open 상태로 전환되기 전에 대기하는 시간을 20초로 설정
  retry:
    instances:
      externalApiRetry: # 재시도 인스턴스 이름
        max-attempts: 4  # 최초 시도 1회 + 재시도 3회 (간격: 1s, 2s, 4s)
        wait-duration: 1000ms # 초기 대기 시간 (1초)
        enable-exponential-backoff: true # 지수 백오프 활성화
        exponential-backoff-multiplier: 2 # 대기 시간 배수 (1s -> 2s -> 4s)
        retry-exceptions: # 재시도할 예외 (일시적 장애)
          - java.io.IOException # 네트워크 연결 실패
          - java.util.concurrent.TimeoutException # 타임아웃
          - feign.RetryableException # Feign 재시도 신호
        ignore-exceptions: # 재시도하지 않을 예외 (클라이언트 에러 등)
          - feign.FeignException.FeignClientException # 4xx 에러 등

management:
  endpoints:
    web:
      exposure:
        include: prometheus, health
  prometheus:
    metrics:
      export:
        enabled: true

eas:
  passport:
    secretKey: ${EAS_PASSPORT_SECRET_KEY}
    expiration: ${EAS_PASSPORT_EXPIRATION}
    algorithm: ${EAS_PASSPORT_ALGORITHM}

